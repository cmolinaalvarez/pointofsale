--- backend/app/dependencies/current_user.py (old)
+++ backend/app/dependencies/current_user.py (new)
@@ -1,5 +1,5 @@
-from __future__ import annotations
-from fastapi import Depends, HTTPException, status
+from typing import Sequence
+from fastapi import Depends, HTTPException, Request, status
 from fastapi.security import OAuth2PasswordBearer
 from sqlalchemy.ext.asyncio import AsyncSession
 from sqlalchemy import select
@@ -10,17 +10,35 @@
 oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")
 
 async def get_current_user(
+    request: Request,
     token: str = Depends(oauth2_scheme),
     db: AsyncSession = Depends(get_async_db),
 ) -> User:
     payload = decode_token(token, expected_type="access")
-    if not payload:
+    if not payload or not (uid := payload.get("sub")):
         raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token inválido")
-    user_id = payload.get("sub")
-    if not user_id:
-        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token inválido")
-    result = await db.execute(select(User).where(User.id == user_id))
+    result = await db.execute(select(User).where(User.id == uid))
     user = result.scalars().first()
     if not user or getattr(user, "active", True) is False:
         raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Usuario no encontrado o inactivo")
+    request.state.user = user
+    request.state.scopes = set(payload.get("scopes", []))
     return user
+
+def require_scopes(required: Sequence[str]):
+    async def _checker(
+        request: Request,
+        _user: User = Depends(get_current_user),
+    ):
+        token_scopes = getattr(request.state, "scopes", set())
+        missing = [s for s in required if s not in token_scopes]
+        if missing:
+            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Permisos insuficientes")
+        return True
+    return _checker
+
+async def current_user_id(request: Request) -> str:
+    u: User | None = getattr(request.state, "user", None)
+    if not u:
+        raise HTTPException(status_code=401, detail="No autenticado")
+    return str(u.id)
--- backend/app/core/security_enhanced.py (old)
+++ backend/app/core/security_enhanced.py (new)
@@ -1,3 +1,17 @@
+# Unified: delegate to central modules
+from app.core.jwt import create_access_token as _create_access_token, decode_token as _decode_token
+from app.dependencies.current_user import get_current_user as get_current_user, require_scopes as require_scopes
+
+def create_access_token(*args, **kwargs):
+    return _create_access_token(*args, **kwargs)
+
+def decode_token(*args, **kwargs):
+    return _decode_token(*args, **kwargs)
+
+# For backward compatibility: single-scope checker
+def require_scope(scope: str):
+    return require_scopes([scope])
+
 from datetime import datetime, timedelta
 from typing import Optional, List
 from jose import JWTError, jwt
@@ -13,11 +27,7 @@
 logger = logging.getLogger(__name__)
 
 # Extender el esquema OAuth2 para incluir scopes
-class OAuth2PasswordBearerWithScopes(OAuth2PasswordBearer):
-    def __init__(self, tokenUrl: str, scopes: List[str] = None):
-        super().__init__(tokenUrl=tokenUrl)
-        self.required_scopes = scopes or []
-
+# unified: removed local OAuth2PasswordBearerWithScopes
 oauth2_scheme = OAuth2PasswordBearerWithScopes(tokenUrl="auth/token")
 
 class TokenBlacklist:
@@ -35,23 +45,7 @@
 
 token_blacklist = TokenBlacklist()
 
-def create_access_token(data: dict, expires_delta: Optional[timedelta] = None, scopes: List[str] = None):
-    to_encode = data.copy()
-    if expires_delta:
-        expire = datetime.utcnow() + expires_delta
-    else:
-        expire = datetime.utcnow() + timedelta(minutes=settings.JWT_ACCESS_TOKEN_EXPIRE_MINUTES)
-    
-    to_encode.update({
-        "exp": expire,
-        "type": "access",
-        "scopes": scopes or ["read"]  # Scopes por defecto
-    })
-    return jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
-
-async def get_current_user(
-    token: str = Depends(oauth2_scheme),
-    db: AsyncSession = Depends(get_async_db)
+# unified: use core.jwt.create_access_token
 ) -> User:
     credentials_exception = HTTPException(
         status_code=status.HTTP_401_UNAUTHORIZED,
@@ -83,21 +77,5 @@
     
     return user
 
-def require_scope(required_scope: str):
-    """Dependency para verificar scopes del token"""
-    def scope_checker(token: str = Depends(oauth2_scheme)):
-        try:
-            payload = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
-            token_scopes = payload.get("scopes", [])
-            if required_scope not in token_scopes:
-                raise HTTPException(
-                    status_code=status.HTTP_403_FORBIDDEN,
-                    detail="Permisos insuficientes"
-                )
-        except JWTError:
-            raise HTTPException(
-                status_code=status.HTTP_401_UNAUTHORIZED,
-                detail="Token inválido"
-            )
-        return token
+# unified: wrapper redefined below
     return scope_checker