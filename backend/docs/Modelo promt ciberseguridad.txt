Quiero implementar cibersegurdidad para el Backend siguiente, teniendo en cuenta que este debe ser reautilizable para los otros endpoint. Por favor explicar cada elemento registrado.

##########################################################################
###########################  Backend FastApi  ############################
##########################################################################

1. Modelo PaymentTerm ubicado en backend/app/models donde backend es el proyecto

# ============================================================
# IMPORTACIONES NECESARIAS
# ============================================================
from sqlalchemy import String, Boolean, DateTime, ForeignKey, Integer, Float
from sqlalchemy.sql import func
from sqlalchemy.orm import Mapped, mapped_column
from app.db.base import Base
import uuid
from sqlalchemy.dialects.postgresql import UUID

# ============================================================
# MODELO DE LA TABLA 'payment_terms' (términos de pago)
# ============================================================
class PaymentTerm(Base):
    __tablename__ = "payment_terms"

    # ID del término de pago (clave primaria)
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Código único del término de pago
    code: Mapped[str] = mapped_column(String(10), unique=True, index=True, nullable=False)
    
    # Nombre del término de pago
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    
    # Descripción del término de pago (opcional)
    description: Mapped[str] = mapped_column(String(500), nullable=True, default="")
    
    # Días netos para pago
    net_days: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    
    # Porcentaje de descuento por pago anticipado
    discount_percent: Mapped[float] = mapped_column(Float, nullable=False, default=0.0)
    
    # Días para aplicar descuento
    discount_days: Mapped[int] = mapped_column(Integer, nullable=False, default=0)
    
    # Base de cálculo (Factura, Recepción, etc.)
    basis: Mapped[str] = mapped_column(String(20), nullable=False, default="Factura")
    
    # Estado del término de pago (activo o no)
    active: Mapped[bool] = mapped_column(Boolean, default=True)
    
    # ID del usuario que creó el término de pago
    user_id: Mapped[UUID] = mapped_column(ForeignKey("users.id"), nullable=False)
    
    # Fecha y hora de creación
    created_at: Mapped[DateTime] = mapped_column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    # Fecha y hora de última actualización
    updated_at: Mapped[DateTime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=True
    )
	
2. Schema PaymentTerm ubicado en backend/app/schemas donde backend es es proyecto

from pydantic import BaseModel, Field, field_validator

from uuid import UUID
from typing import Optional, List
from datetime import datetime
import re

# BASE
class PaymentTermBase(BaseModel):
    code: str = Field(..., min_length=1, max_length=10, description="Código único del término de pago")
    name: str = Field(..., min_length=1, max_length=100, description="Nombre del término de pago")
    description: Optional[str] = Field(None, max_length=500, description="Descripción del término de pago")
    net_days: int = Field(..., ge=0, description="Días netos para pago")
    discount_percent: float = Field(..., ge=0.0, le=100.0, description="Porcentaje de descuento por pago anticipado")
    discount_days: int = Field(..., ge=0, description="Días para aplicar descuento")
    basis: str = Field(..., min_length=1, max_length=20, description="Base de cálculo (Factura, Recepción, etc.)")
    active: bool = Field(True, description="Estado del término de pago")

    @field_validator('code')
    def validate_code(cls, v: str) -> str:
        # Expresión regular corregida
        if not re.match(r'^[A-Z0-9_-]+$', v):
            raise ValueError('El código solo puede contener letras mayúsculas, números, guiones y guiones bajos')
        return v.upper()

    @field_validator('basis')
    def validate_basis(cls, v: str) -> str:
        valid_bases = ["Factura", "Recepción", "Entrega", "Fin de mes"]
        if v not in valid_bases:
            raise ValueError(f'La base debe ser uno de: {", ".join(valid_bases)}')
        return v

# CREATE (POST)
class PaymentTermCreate(PaymentTermBase):
    pass

# UPDATE (PUT)
class PaymentTermUpdate(PaymentTermBase):
    pass

# PATCH (parcial)
class PaymentTermPatch(BaseModel):
    code: Optional[str] = Field(None, min_length=1, max_length=10, description="Código único del término de pago")
    name: Optional[str] = Field(None, min_length=1, max_length=100, description="Nombre del término de pago")
    description: Optional[str] = Field(None, max_length=500, description="Descripción del término de pago")
    net_days: Optional[int] = Field(None, ge=0, description="Días netos para pago")
    discount_percent: Optional[float] = Field(None, ge=0.0, le=100.0, description="Porcentaje de descuento por pago anticipado")
    discount_days: Optional[int] = Field(None, ge=0, description="Días para aplicar descuento")
    basis: Optional[str] = Field(None, min_length=1, max_length=20, description="Base de cálculo (Factura, Recepción, etc.)")
    active: Optional[bool] = Field(None, description="Estado del término de pago")

    @field_validator('code')
    def validate_code(cls, v: str) -> str:
        # Expresión regular corregida
        if not re.match(r'^[A-Z0-9_-]+$', v):
            raise ValueError('El código solo puede contener letras mayúsculas, números, guiones y guiones bajos')
        return v.upper()

    @field_validator('basis')
    def validate_basis(cls, v: str) -> str:
        valid_bases = ["Factura", "Fin de mes"]
        if v not in valid_bases:
            raise ValueError(f'La base debe ser uno de: {", ".join(valid_bases)}')
        return v

# LECTURA (GET)
class PaymentTermRead(PaymentTermBase):
    id: UUID
    user_id: UUID
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

# Respuesta para listado
class PaymentTermListResponse(BaseModel):
    total: int
    items: List[PaymentTermRead]

    class Config:
        from_attributes = True

# Resultado de importación
class PaymentTermImportResult(BaseModel):
    total_imported: int
    total_errors: int
    imported: list
    errors: list
	
3. CRUD Brand ubicado en backend/app/crud donde backend es es proyecto

from sqlalchemy.future import select
from uuid import UUID
from app.models.payment_term import PaymentTerm
from app.schemas.payment_term import PaymentTermCreate, PaymentTermUpdate, PaymentTermPatch
from sqlalchemy.ext.asyncio import AsyncSession
from app.utils.audit import log_action
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from datetime import datetime
import logging
from sqlalchemy import func
from typing import Optional
from fastapi import HTTPException, status
from app.utils.audit_level import get_audit_level

logger = logging.getLogger(__name__)

async def create_payment_term(db: AsyncSession, payment_term_data: dict, user_id: UUID):
    log = None
    
    try:
        # Check if code already exists
        existing = await db.execute(
            select(PaymentTerm).where(PaymentTerm.code == payment_term_data['code'])
        )
        if existing.scalar_one_or_none():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Payment term with code '{payment_term_data['code']}' already exists"
            )
        print("#########################   current_user ##################################",user_id);
        payment_term_data['user_id'] = user_id       
        
        payment_term = PaymentTerm(**payment_term_data)
        db.add(payment_term)
        await db.flush()
        
        # Create audit log if needed
        audit_level = await get_audit_level(db)
        if audit_level and audit_level >= 2:
            log = await log_action(
                db=db,
                action="CREATE",
                table_name="payment_terms",
                record_id=payment_term.id,
                user_id=user_id,
                old_values={},
                new_values=payment_term_data
            )
        
        await db.commit()
        await db.refresh(payment_term)
        return payment_term, log
        
    except HTTPException:
        await db.rollback()
        raise
    except Exception as e:
        await db.rollback()
        logger.error(f"Error al crear término de pago: {str(e)}")
        raise e
    
    
async def get_payment_terms(
    db: AsyncSession,
    skip: int = 0,
    limit: int = 100,
    search: Optional[str] = None,
    active: Optional[bool] = None,
    user_id: Optional[UUID] = None,
) -> dict:
    """
    Obtener lista de términos de pago con paginación y filtros
    """
    try:
        query = select(PaymentTerm)

        # Aplicar filtros
        if search:
            query = query.where(
                (PaymentTerm.name.ilike(f"%{search}%")) | 
                (PaymentTerm.code.ilike(f"%{search}%")) |
                (PaymentTerm.description.ilike(f"%{search}%"))
            )
        if active is not None:
            query = query.where(PaymentTerm.active == active)

        # Calcular total
        total_query = select(func.count()).select_from(query.subquery())
        total_result = await db.execute(total_query)
        total = total_result.scalar_one()

        # Obtener resultados paginados
        result = await db.execute(
            query.offset(skip).limit(limit).order_by(PaymentTerm.name)
        )
        payment_terms = result.scalars().all()
        
        # Registrar auditoría si es necesario
        audit_level = await get_audit_level(db)
        if audit_level > 2 and user_id:
            await log_action(
                db,
                action="GETALL",
                entity="PaymentTerm",
                description=f"Consulta de términos de pago - filtros: search='{search}', active={active}, skip={skip}, limit={limit}",
                user_id=user_id,
            )
        
        return {"total": total, "items": payment_terms}
        
    except SQLAlchemyError as e:
        logger.error("Error de base de datos en get_payment_terms: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al obtener términos de pago"
        )
    except Exception as e:
        logger.exception("Error inesperado en get_payment_terms", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error inesperado al obtener términos de pago"
        )

async def get_payment_term_by_id(
    db: AsyncSession,
    payment_term_id: UUID,
    user_id: Optional[UUID] = None
) -> PaymentTerm:
    """
    Obtener un término de pago por ID
    """
    try:
        result = await db.execute(
            select(PaymentTerm).where(PaymentTerm.id == payment_term_id)
        )
        payment_term = result.scalars().first()

        if not payment_term:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Término de pago no encontrado"
            )
        
        # Registrar auditoría si es necesario
        audit_level = await get_audit_level(db)
        if audit_level > 2 and user_id:
            await log_action(
                db,
                action="GETID",
                entity="PaymentTerm",
                entity_id=payment_term.id,
                description=f"Consultó término de pago: {payment_term.name}",
                user_id=user_id
            )
        
        return payment_term
        
    except HTTPException:
        raise
    except SQLAlchemyError as e:
        logger.error("Error de base de datos en get_payment_term_by_id: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error al obtener término de pago"
        )
    except Exception as e:
        logger.exception("Error inesperado en get_payment_term_by_id", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error inesperado al obtener término de pago"
        )

async def update_payment_term(
    db: AsyncSession,
    payment_term_id: UUID,
    payment_term_data: dict,
    user_id: UUID
):
    """
    Actualizar un término de pago
    """
    try:
        # Buscar término de pago existente
        result = await db.execute(
            select(PaymentTerm).where(PaymentTerm.id == payment_term_id)
        )
        payment_term = result.scalars().first()
        
        if not payment_term:
            return None, None

        cambios = []
        
        # Verificar y aplicar cambios
        for field, value in payment_term_data.items():
            if hasattr(payment_term, field) and getattr(payment_term, field) != value:
                cambios.append(f"{field}: '{getattr(payment_term, field)}' → '{value}'")
                setattr(payment_term, field, value)

        # Si no hay cambios, retornar sin hacer nada
        if not cambios:
            return payment_term, None

        # Actualizar timestamp
        payment_term.updated_at = datetime.utcnow()
        
        # Registrar auditoría
        audit_level = await get_audit_level(db)
        if audit_level >= 1:
            log = await log_action(
                db,
                action="UPDATE",
                entity="PaymentTerm",
                entity_id=payment_term.id,
                description=f"Cambios en término de pago: {', '.join(cambios)}",
                user_id=user_id,
            )
        
        await db.flush()
        return payment_term, log
        
    except IntegrityError as e:
        await db.rollback()
        if "duplicate key" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Ya existe un término de pago con este código"
            )
        logger.error("Error de integridad al actualizar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Error de integridad de datos"
        )
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error("Error SQLAlchemy al actualizar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error en la base de datos"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al actualizar término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error inesperado al actualizar término de pago"
        )

async def patch_payment_term(
    db: AsyncSession,
    payment_term_id: UUID,
    payment_term_data: dict,
    user_id: UUID
):
    """
    Actualizar parcialmente un término de pago (PATCH)
    """
    try:
        # Buscar término de pago existente
        result = await db.execute(
            select(PaymentTerm).where(PaymentTerm.id == payment_term_id)
        )
        payment_term = result.scalars().first()
        
        if not payment_term:
            return None, None

        cambios = []
        
        # Aplicar solo los campos proporcionados
        for field, value in payment_term_data.items():
            if hasattr(payment_term, field) and getattr(payment_term, field) != value:
                cambios.append(f"{field}: '{getattr(payment_term, field)}' → '{value}'")
                setattr(payment_term, field, value)

        # Si no hay cambios, retornar sin hacer nada
        if not cambios:
            return payment_term, None

        # Actualizar timestamp
        payment_term.updated_at = datetime.utcnow()
        
        # Registrar auditoría
        audit_level = await get_audit_level(db)
        if audit_level >= 1:
            log = await log_action(
                db,
                action="PATCH",
                entity="PaymentTerm",
                entity_id=payment_term.id,
                description=f"Actualización parcial: {', '.join(cambios)}",
                user_id=user_id,
            )
        
        await db.flush()
        return payment_term, log
        
    except IntegrityError as e:
        await db.rollback()
        if "duplicate key" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Ya existe un término de pago con este código"
            )
        logger.error("Error de integridad al actualizar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Error de integridad de datos"
        )
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error("Error SQLAlchemy al actualizar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error en la base de datos"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al actualizar término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error inesperado al actualizar término de pago"
        )

async def delete_payment_term(
    db: AsyncSession,
    payment_term_id: UUID,
    user_id: UUID
) -> bool:
    """
    Eliminar un término de pago
    """
    try:
        # Buscar término de pago existente
        result = await db.execute(
            select(PaymentTerm).where(PaymentTerm.id == payment_term_id)
        )
        payment_term = result.scalars().first()
        
        if not payment_term:
            return False

        # Eliminar término de pago
        await db.delete(payment_term)
        
        # Registrar auditoría
        audit_level = await get_audit_level(db)
        if audit_level >= 1:
            await log_action(
                db,
                action="DELETE",
                entity="PaymentTerm",
                entity_id=payment_term_id,
                description=f"Término de pago eliminado: {payment_term.name}",
                user_id=user_id,
            )
        
        await db.flush()
        return True
        
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error("Error SQLAlchemy al eliminar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error en la base de datos al eliminar término de pago"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al eliminar término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error inesperado al eliminar término de pago"
        )
		
4. router PaymentTerm ubicado en backend/app/routers donde backend es el proyecto

from fastapi import APIRouter, Depends, HTTPException, status, Query, UploadFile, File
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from uuid import UUID
from typing import List, Optional
import csv
from io import StringIO
import time

from app.schemas.payment_term import (
    PaymentTermCreate, PaymentTermUpdate, PaymentTermRead, 
    PaymentTermPatch, PaymentTermImportResult, PaymentTermListResponse
)
from app.crud.payment_term import (
    create_payment_term, get_payment_terms, get_payment_term_by_id, 
    update_payment_term, patch_payment_term, delete_payment_term
)
from app.models.user import User
from app.dependencies.current_user import get_current_user
from app.core.security import get_async_db
from app.utils.audit import log_action
from app.utils.audit_level import get_audit_level

import logging
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/paymentterms", tags=["PaymentTerms"])

# ==============================
# CREATE - POST
# ==============================
@router.post("/", response_model=PaymentTermRead, status_code=status.HTTP_201_CREATED)
async def create_payment_term_endpoint(
    payment_term_in: PaymentTermCreate,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Crear un nuevo término de pago
    """
    try:
        new_payment_term, log = await create_payment_term(
            db, payment_term_in.model_dump(), current_user.id
        )
        
        if log:
            db.add(log)
            
        await db.commit()
        await db.refresh(new_payment_term)
        
        logger.info(f"Término de pago creado exitosamente: {new_payment_term.id} - {new_payment_term.name} por usuario {current_user.id}")
        return PaymentTermRead.model_validate(new_payment_term)
        
    except HTTPException:
        await db.rollback()
        raise
    except IntegrityError as e:
        await db.rollback()
        logger.error("Error de integridad al crear término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Error de integridad de datos: " + str(e.orig)
        )
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error("Error de SQLAlchemy al crear término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Error en la base de datos"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error interno al crear término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error interno: {str(e)}"
        )

# ==============================
# GET ALL
# ==============================
@router.get("/", response_model=PaymentTermListResponse)
async def list_payment_terms(
    skip: int = Query(0, ge=0, description="Número de registros a saltar"),
    limit: int = Query(100, ge=1, le=1000, description="Límite de registros por página"),
    search: Optional[str] = Query(None, description="Término de búsqueda"),
    active: Optional[bool] = Query(None, description="Filtrar por estado activo/inactivo"),
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Listar términos de pago con paginación y filtros
    """
    try:
        result = await get_payment_terms(db, skip, limit, search, active, current_user.id)
        await db.commit()
        return result
        
    except SQLAlchemyError as e:
        await db.rollback()
        logger.error("Error de base de datos al listar términos de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocurrió un error en la base de datos al obtener los términos de pago"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al listar términos de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocurrió un error al obtener los términos de pago"
        )

# ==============================
# GET BY ID
# ==============================
@router.get("/{payment_term_id}", response_model=PaymentTermRead)
async def read_payment_term(
    payment_term_id: UUID,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Obtener un término de pago por ID
    """
    try:
        payment_term = await get_payment_term_by_id(db, payment_term_id, current_user.id)
        await db.commit()
        return PaymentTermRead.model_validate(payment_term)
        
    except HTTPException as e:
        await db.rollback()
        raise e
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al obtener el término de pago por ID", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Ocurrió un error al consultar el término de pago"
        )

# ==============================
# UPDATE - PUT
# ==============================
@router.put("/{payment_term_id}", response_model=PaymentTermRead)
async def update_payment_term_endpoint(
    payment_term_id: UUID,
    payment_term_in: PaymentTermUpdate,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Actualizar un término de pago
    """
    try:
        updated, log = await update_payment_term(
            db, payment_term_id, payment_term_in.model_dump(), current_user.id
        )
        
        if not updated:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Término de pago no encontrado"
            )
            
        if log:
            db.add(log)
            
        await db.commit()
        await db.refresh(updated)
        
        return PaymentTermRead.model_validate(updated)
        
    except HTTPException:
        await db.rollback()
        raise
    except IntegrityError as e:
        await db.rollback()
        logger.error("Error de integridad al actualizar término de pago: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Error de integridad (código duplicado u otra restricción)."
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al actualizar término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error interno: {str(e)}"
        )

# ==============================
# PARTIAL UPDATE - PATCH
# ==============================
@router.patch("/{payment_term_id}", response_model=PaymentTermRead)
async def patch_payment_term_endpoint(
    payment_term_id: UUID,
    payment_term_in: PaymentTermPatch,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Actualizar parcialmente un término de pago
    """
    try:
        updated, log = await patch_payment_term(
            db, payment_term_id, payment_term_in.model_dump(exclude_unset=True), current_user.id
        )
        
        if not updated:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Término de pago no encontrado"
            )
            
        if log:
            db.add(log)
            
        await db.commit()
        await db.refresh(updated)
        
        logger.info(f"Término de pago {payment_term_id} actualizado parcialmente correctamente.")
        return PaymentTermRead.model_validate(updated)
        
    except HTTPException:
        await db.rollback()
        raise
    except IntegrityError as e:
        await db.rollback()
        logger.error("Error de integridad al actualizar término de pago (PATCH): %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Error de integridad (código duplicado u otra restricción)."
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al actualizar término de pago (PATCH)", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error interno: {str(e)}"
        )

# ==============================
# DELETE
# ==============================
@router.delete("/{payment_term_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_payment_term_endpoint(
    payment_term_id: UUID,
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Eliminar un término de pago
    """
    try:
        deleted = await delete_payment_term(db, payment_term_id, current_user.id)
        
        if not deleted:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Término de pago no encontrado"
            )
            
        await db.commit()
        
    except HTTPException:
        await db.rollback()
        raise
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado al eliminar término de pago", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error interno: {str(e)}"
        )

# ==============================
# IMPORT MASSIVE PAYMENT TERMS
# ==============================
@router.post("/import", response_model=PaymentTermImportResult, status_code=status.HTTP_201_CREATED)
async def import_payment_terms(
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_async_db),
    current_user: User = Depends(get_current_user),
):
    """
    Importar términos de pago desde archivo CSV
    """
    try:
        content = await file.read()
        csv_reader = csv.DictReader(StringIO(content.decode("utf-8")))
        
        # Limpiar headers
        if csv_reader.fieldnames:
            csv_reader.fieldnames = [h.strip().replace('\ufeff', '') for h in csv_reader.fieldnames]
            logger.info(f"Headers después de limpieza: {csv_reader.fieldnames}")
            
        payment_terms = []
        imported_count = 0
        error_count = 0
        errors = []
        
        for row_number, row in enumerate(csv_reader, 1):
            try:
                # Validar y procesar fila
                payment_term_data = {
                    "code": row["code"],
                    "name": row["name"],
                    "description": row.get("description", ""),
                    "net_days": int(row["net_days"]),
                    "discount_percent": float(row["discount_percent"]),
                    "discount_days": int(row["discount_days"]),
                    "basis": row["basis"],
                    "active": row.get("active", "true").lower() in ("true", "1", "yes", "si")
                }
                
                # Crear término de pago
                payment_term = await create_payment_term(db, payment_term_data, current_user.id)
                payment_terms.append(payment_term)
                imported_count += 1
                
            except Exception as row_err:
                error_count += 1
                error_msg = f"Fila {row_number}: {str(row_err)}"
                errors.append(error_msg)
                logger.warning("Fila con error en importación de términos de pago: %s", error_msg, exc_info=True)
        
        # Registrar auditoría de importación
        audit_level = await get_audit_level(db)
        if audit_level > 1:
            await log_action(
                db,
                action="IMPORT",
                entity="PaymentTerm",
                description=f"Importación masiva: {imported_count} términos de pago importados.",
                user_id=current_user.id
            )
            
        await db.commit()
        
        logger.info("Importación masiva de términos de pago exitosa. Total importados: %d", imported_count)
        
        return PaymentTermImportResult(
            total_imported=imported_count,
            total_errors=error_count,
            imported=[pt.id for pt in payment_terms],
            errors=errors
        )
        
    except IntegrityError as e:
        await db.rollback()
        logger.error("Error de integridad en importación masiva: %s", e, exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Error de integridad (término de pago duplicado): {str(e.orig)}"
        )
    except Exception as e:
        await db.rollback()
        logger.exception("Error inesperado en importación masiva", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error interno: {str(e)}"
        )

5. jwt ubicado en backend/app/core donde backend es el proyecto

# Importamos datetime y timedelta para manejar fechas y tiempos
from datetime import datetime, timedelta

# Importamos herramientas para trabajar con JWT (JSON Web Tokens)
# - JWTError: para manejar errores si el token es inválido
# - jwt: la librería que codifica y decodifica los tokens
from jose import JWTError, jwt

# Importamos Optional para poder indicar que un parámetro puede ser opcional (None)
from typing import Optional

# Importamos la configuración global
from app.core.config import settings


# ===============================================================
# CONFIGURACIÓN GLOBAL PARA LOS TOKENS (desde settings)
# ===============================================================

# Obtenemos los valores desde la configuración global
SECRET_KEY = settings.jwt_secret_key
ALGORITHM = settings.jwt_algorithm
ACCESS_TOKEN_EXPIRE_MINUTES = settings.jwt_access_token_expire_minutes


# ===============================================================
# FUNCIÓN PARA CREAR UN TOKEN JWT (para acceso)
# ===============================================================

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None, scopes: list = None):
    """
    Crea un token JWT con los datos del usuario, tiempo de expiración y scopes.

    Parámetros:
    - data: diccionario con datos a incluir en el token (por ejemplo, el ID del usuario)
    - expires_delta: duración personalizada del token (opcional)
    - scopes: lista de permisos/scopes del token (opcional)

    Retorna:
    - Un string codificado que representa el token JWT
    """
    # Hacemos una copia de los datos (para no modificar el original)
    to_encode = data.copy()

    # Calculamos la fecha de expiración:
    # - Si se pasó un valor personalizado (`expires_delta`), lo usamos.
    # - Si no, usamos el valor por defecto (60 minutos).
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))

    # Agregamos la fecha de expiración al diccionario
    to_encode.update({"exp": expire})
    
    # Agregamos scopes si se proporcionaron
    if scopes:
        to_encode.update({"scopes": scopes})
    else:
        to_encode.update({"scopes": ["read"]})  # Scope por defecto

    # Codificamos el token usando la clave secreta y el algoritmo definido
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

    # Codificamos el token usando la clave secreta y el algoritmo definido
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


# ===============================================================
# FUNCIÓN PARA DECODIFICAR UN TOKEN JWT
# ===============================================================

def decode_access_token(token: str):
    """
    Decodifica un token JWT y retorna los datos si es válido.

    Parámetro:
    - token: el JWT en forma de texto

    Retorna:
    - Diccionario con los datos del token si es válido
    - None si el token es inválido o está vencido
    """
    try:
        # Decodificamos el token con la clave secreta y el algoritmo correcto
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except JWTError:
        # Si ocurre un error (token inválido, expirado, etc.), retornamos None
        return None
		
6. security ubicado en backend/app/core donde backend es el proyecto

# ================================================================
# MÓDULO DE SEGURIDAD
# - Maneja hashing de contraseñas y verificación segura.
# - Obtiene el usuario actual desde el token (asincrónicamente).
# - Prepara sesiones de base de datos asincrónicas.
# ================================================================

# ---------------------------------------------------------------
# Importamos tipos para anotación de funciones asincrónicas
# ---------------------------------------------------------------
from typing import AsyncGenerator

# ---------------------------------------------------------------
# Clase base para sesiones asincrónicas de SQLAlchemy
# ---------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession

# ---------------------------------------------------------------
# Importamos nuestro sessionmaker asincrónico personalizado
# ---------------------------------------------------------------
from app.db.async_session import AsyncSessionLocal

# ---------------------------------------------------------------
# Importamos CryptContext de Passlib para hashing de contraseñas
# ---------------------------------------------------------------
from passlib.context import CryptContext

# ---------------------------------------------------------------
# Función estándar de asyncio para ejecutar código bloqueante
# en un hilo separado, sin bloquear el event loop principal
# ---------------------------------------------------------------
import asyncio

# ================================================================
# DEPENDENCIA PARA BASE DE DATOS ASINCRÓNICA
# - Usada en endpoints y servicios para obtener una sesión válida
# - Se cierra automáticamente después del uso
# ================================================================
async def get_async_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session
        # La sesión se cierra automáticamente al salir del bloque

# ================================================================
# CONTEXTO DE HASHING DE CONTRASEÑAS
# - Usa bcrypt (recomendado por OWASP)
# - Configura el esquema para hashear y verificar
# ================================================================
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# ================================================================
# FUNCIONES ASÍNCRONAS PARA HASHING DE CONTRASEÑAS
# - Usan asyncio.to_thread para evitar bloquear el event loop
# ================================================================

async def get_password_hash(password: str) -> str:
    """
    Devuelve el hash seguro de la contraseña.
    Ejecutado en un hilo separado para no bloquear el event loop.
    """
    return await asyncio.to_thread(pwd_context.hash, password)

async def verify_password(plain_password: str, password: str) -> bool:
    """
    Verifica que la contraseña en texto plano coincida con el hash.
    Ejecutado en un hilo separado para no bloquear el event loop.
    """
    return await asyncio.to_thread(pwd_context.verify, plain_password, password)
	
	
	